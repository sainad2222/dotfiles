[Special]
wordchars=._abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

[Default]
skeleton=\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INT\t\t\t long long\n#define endl\t\t\t"\\n"\n#define inpArr(vec)\t\t  for(auto &it:vec) cin>>it\n#define outArr(vec)\t\t  for(auto &it:vec) cout<<it<<" ";cout<<endl;\n\n\nvoid solve(){\n\t\n}\n\n\n\n\nint main(){\nios_base::sync_with_stdio(0);cin.tie(NULL);\n\nint tt=1;\ncin >> tt;\nwhile(tt--){\n\tsolve();\n}\n\nreturn 0;\n\t\n}\n\n
debugCpp=\ntemplate<typename T>\nint SIZE(T (&t)){\n\treturn t.size();\n}\n\ntemplate<typename T, size_t N>\nint SIZE(T (&t)[N]){\n\treturn N;\n}\n\nstring to_string(char t){\n\treturn "'" + string({t}) + "'";\n}\n\nstring to_string(bool t){\n\treturn t ? "true" : "false";\n}\n\nstring to_string(const string &t, int x1=0, int x2=1e9){\n\tstring ret = "";\n\tfor(int i = min(x1,SIZE(t)), _i = min(x2,SIZE(t)-1); i <= _i; ++i){\n\t\tret += t[i];\n\t}\n\treturn '"' + ret + '"';\n}\n\nstring to_string(const char* t){\n\tstring ret(t);\n\treturn to_string(ret);\n}\n\ntemplate<size_t N>\nstring to_string(const bitset<N> &t, int x1=0, int x2=1e9){\n\tstring ret = "";\n\tfor(int i = min(x1,SIZE(t)); i <= min(x2,SIZE(t)-1); ++i){\n\t\tret += t[i] + '0';\n\t}\n\treturn to_string(ret);\n}\n\ntemplate<typename T, typename... Coords>\nstring to_string(const T (&t), int x1=0, int x2=1e9, Coords... C);\n\ntemplate<typename T, typename S>\nstring to_string(const pair<T, S> &t){\n\treturn "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\n\ntemplate<typename T, typename... Coords>\nstring to_string(const T (&t), int x1, int x2, Coords... C){\n\tstring ret = "[";\n\tx1 = min(x1, SIZE(t));\n\tauto e = begin(t);\n\tadvance(e,x1);\n\tfor(int i = x1, _i = min(x2,SIZE(t)-1); i <= _i; ++i){\n\t\tret += to_string(*e, C...) + (i != _i ? ", " : "");\n\t\te = next(e);\n\t}\n\treturn ret + "]";\n}\n\ntemplate<int Index, typename... Ts>\nstruct print_tuple{\n\tstring operator() (const tuple<Ts...>& t) {\n\t\tstring ret = print_tuple<Index - 1, Ts...>{}(t);\n\t\tret += (Index ? ", " : "");\n\t\treturn ret + to_string(get<Index>(t));\n\t}\n};\n\ntemplate<typename... Ts>\nstruct print_tuple<0, Ts...> {\n\tstring operator() (const tuple<Ts...>& t) {\n\t\treturn to_string(get<0>(t));\n\t}\n};\n\ntemplate<typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n\tconst auto Size = tuple_size<tuple<Ts...>>::value;\n\treturn print_tuple<Size - 1, Ts...>{}(t);\n}\n\nvoid dbgr(){;}\ntemplate<typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T){\n\tcout << to_string(H) << " | ";\n\tdbgr(T...);\n}\n\nvoid dbgs(){;}\ntemplate<typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T){\n\tcout << H << " ";\n\tdbgs(T...);\n}\n\n/*\nformatted functions:\n*/\n\n/*\nconsider __VA_ARGS__ as a whole:\ndbgv() prints values only\ndbg() prints name and values\n*/\n#define dbgv(...) cout << to_string(__VA_ARGS__) << endl;\n\n#define dbg(...) cout << "[" << #__VA_ARGS__ << "]: "; dbgv(__VA_ARGS__);\n\n


[Python]
splitInput=%cursor% = map(int,input().split())
unique=def unique(lis):\n\tprev = -1\n\tres = []\n\tfor i in lis:\n\t\tif i != prev:\n\t\t\tres.append(i)\n\t\t\tprev = i\n\treturn res\n
Test=for _ in range(int(input())):\n\t
listInput=%cursor% = list(map(int,input().split()))\n
binSearch=\ndef binary_search(array):\n\tleft, right = 0, len(array)\n\twhile left <= right:\n\t\tmid = left + (right - left) // 2\n\t\tif condition(mid):\n\t\t\tright = mid - 1\n\t\telse:\n\t\t\tleft = mid + 1\n\treturn left\n\n
isPrime=\ndef isPrime(n):\n\tif n==1:\n\t\treturn False\n\ti=2\n\twhile(i*i<=n):\n\t\tif n%i==0:\n\t\t\treturn False\n\t\ti+=1\n\treturn True\n\n
primeSeive=\ndef primeSeive(n):\n\tprime = [True for i in range(n + 1)]\n\tprimes = []\n\tp = 2\n\twhile (p * p <= n):\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * 2, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tprime[0] = False\n\tprime[1] = False\n\tfor p in range(n + 1):\n\t\tif prime[p]:\n\t\t\tprimes.append(p)\n\treturn primes\n\n
template=\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n\tpass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif sys.version_info[0] < 3:\n\tfrom __builtin__ import xrange as range\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\n\n"""\nregion fastio\nCredits\ntemplate credits to cheran-senthil's github Repo\n"""\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = "x" in file.mode or "r" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b"\\n") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode("ascii"))\n\t\tself.read = lambda: self.buffer.read().decode("ascii")\n\t\tself.readline = lambda: self.buffer.readline().decode("ascii")\n\n\ndef print(*args, **kwargs):\n\t"""Prints the values to a stream, or to sys.stdout by default."""\n\tsep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop("end", "\\n"))\n\tif kwargs.pop("flush", False):\n\t\tfile.flush()\n\n\nif sys.version_info[0] < 3:\n\tsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n\tsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip("\\r\\n")\n\n\n\nif __name__ == "__main__":\n\tmain()\n\n
fenwick=\nclass BIT:\n\tdef __init__(self, lis, n):\n\t\tself.n = n\n\t\tself.array = [0]+lis\n\t\tfor idx in range(1,n):\n\t\t\tidx2 = idx+(idx & -idx)\n\t\t\tif idx2 < n:\n\t\t\t\tself.array[idx2] += self.array[idx]\n\t\n\tdef prefix_query(self,idx):\n\t\tidx+=1\n\t\tresult = 0\n\t\twhile idx>0:\n\t\t\tresult += self.array[idx]\n\t\t\tidx -= (idx & -idx)\n\t\treturn result\n\t\n\tdef range_query(self, from_idx, to_idx):\n\t\treturn self.prefix_query(to_idx) - self.prefix_query(from_idx-1)\n\t\n\tdef update(self,idx,add):\n\t\tidx+=1\n\t\twhile idx<=self.n:\n\t\t\tself.array[idx]+=add\n\t\t\tidx += idx & -idx\n\t\t\n\tdef __str__(self):\n\t\treturn ' '.join(map(str, self.array))\n\n
graphclass=\nimport sys\nfrom collections import deque as queue\nsys.setrecursionlimit(10 ** 6)\nclass Graph(object):\n\n\tdef __init__(self):\n\t\tself.neighbours = {}\n\t\n\tdef __repr__(self):\n\t\ts = ''\n\t\tfor i in self.neighbours:\n\t\t\ts += str(i)+': '+' '.join(map(str,self.neighbours[i])) + '\\n'\n\t\treturn s\n\t\n\tdef add_node(self, node):\n\t\tself.neighbours[node] = set()\n\t\n\tdef add_edge(self, edge):\n\t\tu, v = edge\n\t\tself.neighbours[u].add(v)\n\t\tself.neighbours[v].add(u)\n\t\n\tdef dfs(self, node):\n\t\tvisited[node] = 1\n\t\tfor child in self.neighbours[node]:\n\t\t\tif visited[child] == 0:\n\t\t\t\tself.dfs(child)\n\t\n\tdef bfs(self, node):\n\t\tq = queue()\n\t\tvisited[node] = 1\n\t\tq.append(node)\n\t\twhile q:\n\t\t\tcur = q.popleft()\n\t\t\tfor child in self.neighbours[cur]:\n\t\t\t\tif visited[child] == 0:\n\t\t\t\t\tq.append(child)\n\t\t\t\t\tvisited[child] = 1\n\ng = Graph()\nn, e = map(int, input().split())\nfor i in range(n):\n\tg.add_node(i+1)\nfor i in range(e):\n\tx, y = map(int, input().split())\n\tg.add_edge((x, y))\nvisited = [0] * (n + 1)\n\n
bootstrap=\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\n
binPow=\ndef binPow(n, r):\n\tc = 1\n\twhile r > 0:\n\t\tif r & 1:\n\t\t\tr -= 1\n\t\t\tc *= n\n\t\tr = r // 2\n\t\tn = n ** 2\n\treturn c\n\n
ceil=\ndef ceil(a, b):\n\treturn (a + b - 1) // b\n\n
mergeSort=\ndef mergesort(arr, n):\n\ttemp_arr = [0] * n\n\treturn _mergesort(arr, temp_arr, 0, n - 1)\n\ndef _mergesort(arr, temp, l, r):\n\tans = 0\n\tif l < r:\n\t\tmid = (l + r) // 2\n\t\tans += _mergesort(arr, temp, l, mid)\n\t\tans += _mergesort(arr, temp, mid + 1, r)\n\t\tans += merge(arr, temp, l, mid, r)\n\treturn ans\n\ndef merge(arr, temp, l, mid, r):\n\tcount = 0\n\ti = l\n\tj = mid + 1\n\tnxt = l\n\twhile i <= mid and j <= r:\n\t\tif arr[i] <= arr[j]:\n\t\t\ttemp[nxt] = arr[i]\n\t\t\tnxt += 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tcount += (mid - i + 1)\n\t\t\ttemp[nxt] = arr[j]\n\t\t\tnxt += 1\n\t\t\tj += 1\n\t\n\twhile i <= mid:\n\t\ttemp[nxt] = arr[i]\n\t\tnxt += 1\n\t\ti += 1\n\t\n\twhile j <= r:\n\t\ttemp[nxt] = arr[j]\n\t\tnxt += 1\n\t\tj += 1\n\t\n\tarr[l:r+1] = temp[l:r+1][:]\n\t\n\treturn count\n\n
primeFactors=\ndef primeFactors(n):\n\tdic = defaultdict(int)\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tdic[2] += 1\n\t\tn = n // 2\n\t\n\ti = 3\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tdic[i] += 1\n\t\t\tn = n // i\n\t\ti += 2\n\t\n\tif n > 2:\n\t\tdic[n] += 1\n\treturn dic\n\n
