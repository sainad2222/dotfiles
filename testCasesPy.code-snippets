{
	"first line": {
		"prefix": "Test",
		"body": [
		  "for _ in range(int(input())):"
		],
		"description": "first line"
	  },
	  "taking a line of inputs": {
		"prefix": "listInput",
		"body": [
		  "$1 = list(map(int,input().split()))"
		],
		"description": "taking a line of inputs"
	  },
	  "taking one input": {
		"prefix": "Input",
		"body": [
		  "$1=int(input())"
		],
		"description": "taking one input"
	  },
	  "taking two inputs": {
		"prefix": "twoInput",
		"body": [
		  "$1,$2=map(int,input().split())"
		],
		"description": "taking two inputs"
	  },
	  "taking three inputs": {
		"prefix": "threeInput",
		"body": [
		  "$1,$2,$3=map(int,input().split())"
		],
		"description": "taking three inputs"
	  },
	  "taking four inputs": {
		"prefix": "fourInput",
		"body": [
		  "$1,$2,$3,$4=map(int,input().split())"
		],
		"description": "taking four inputs"
	  },
	  "binary search template": {
		"prefix": "binSearch",
		"body": [
		  "def binary_search(array):",
		  "    def condition(value):",
		  "        pass",
		  "",
		  "    left, right = 0, len(array)",
		  "    while left < right:",
		  "        mid = left + (right - left) // 2",
		  "        if condition(mid):",
		  "            right = mid",
		  "        else:",
		  "            left = mid + 1",
		  "    return left"
		],
		"description": "binary search template"
	  },
	  "ternary search": {
		"prefix": "ternary",
		"body": [
		  "def ternarySearch(arr,x,l,r):",
		  "    while(r>=l):",
		  "        mid1=l+(r-l)//3",
		  "        mid2=r-(r-l)//3",
		  "        if(x==arr[mid1]):",
		  "            return mid1",
		  "        elif(x==arr[mid2]):",
		  "            return mid2",
		  "        if(x<arr[mid1]):",
		  "            r=mid1-1",
		  "        elif(x>arr[mid2]):",
		  "            l=mid2+1",
		  "        else:",
		  "            l=mid1+1",
		  "            r=mid2-1",
		  "    return -1"
		],
		"description": "ternary search"
	  },
	  "Seive": {
		"prefix": "primeSeive",
		"body": [
		  "def SieveOfEratosthenes(n): ",
		  "    prime = [True for i in range(n + 1)] ",
		  "    p = 2",
		  "    while (p * p <= n): ",
		  "        if (prime[p] == True): ",
		  "            for i in range(p * 2, n + 1, p): ",
		  "                prime[i] = False",
		  "        p += 1",
		  "    prime[0]= False",
		  "    prime[1]= False ",
		  "    for p in range(n + 1): ",
		  "        if prime[p]: ",
		  "            print(p)"
		],
		"description": "Seive"
	  },
	  "prime number check": {
		"prefix": "isPrime",
		"body": [
		  "def isPrime(n):",
		  "    if n==1:",
		  "        return False",
		  "    i=2",
		  "    while(i*i<=n):",
		  "        if n%i==0:",
		  "            return False",
		  "        i+=1",
		  "    return True"
		],
		"description": "prime number check"
	  },
	  "template": {
		"prefix": "template",
		"body": [
		  "from __future__ import division, print_function",
		  "",
		  "import os",
		  "import sys",
		  "from io import BytesIO, IOBase",
		  "",
		  "def main():",
		  "    pass",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "",
		  "if sys.version_info[0] < 3:",
		  "    from __builtin__ import xrange as range",
		  "    from future_builtins import ascii, filter, hex, map, oct, zip",
		  "",
		  "# region fastio",
		  "# Credits",
		  "# # template credits to cheran-senthil's github Repo",
		  "",
		  "BUFSIZE = 8192",
		  "",
		  "",
		  "class FastIO(IOBase):",
		  "    newlines = 0",
		  "",
		  "    def __init__(self, file):",
		  "        self._fd = file.fileno()",
		  "        self.buffer = BytesIO()",
		  "        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
		  "        self.write = self.buffer.write if self.writable else None",
		  "",
		  "    def read(self):",
		  "        while True:",
		  "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "            if not b:",
		  "                break",
		  "            ptr = self.buffer.tell()",
		  "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "        self.newlines = 0",
		  "        return self.buffer.read()",
		  "",
		  "    def readline(self):",
		  "        while self.newlines == 0:",
		  "            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		  "            self.newlines = b.count(b\"\\n\") + (not b)",
		  "            ptr = self.buffer.tell()",
		  "            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
		  "        self.newlines -= 1",
		  "        return self.buffer.readline()",
		  "",
		  "    def flush(self):",
		  "        if self.writable:",
		  "            os.write(self._fd, self.buffer.getvalue())",
		  "            self.buffer.truncate(0), self.buffer.seek(0)",
		  "",
		  "",
		  "class IOWrapper(IOBase):",
		  "    def __init__(self, file):",
		  "        self.buffer = FastIO(file)",
		  "        self.flush = self.buffer.flush",
		  "        self.writable = self.buffer.writable",
		  "        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
		  "        self.read = lambda: self.buffer.read().decode(\"ascii\")",
		  "        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
		  "",
		  "",
		  "def print(*args, **kwargs):",
		  "    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"",
		  "    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)",
		  "    at_start = True",
		  "    for x in args:",
		  "        if not at_start:",
		  "            file.write(sep)",
		  "        file.write(str(x))",
		  "        at_start = False",
		  "    file.write(kwargs.pop(\"end\", \"\\n\"))",
		  "    if kwargs.pop(\"flush\", False):",
		  "        file.flush()",
		  "",
		  "",
		  "if sys.version_info[0] < 3:",
		  "    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)",
		  "else:",
		  "    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
		  "",
		  "input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
		  "",
		  "# endregion",
		  "",
		  "",
		  "if __name__ == \"__main__\":",
		  "    main()"
		],
		"description": "template"
	  },
	  "fenwick tree class": {
		"prefix": "fenwick",
		"body": [
		  "class BIT:",
		  "    def __init__(self,list):",
		  "        self.array = [0]+list",
		  "        for idx in range(1,len(self.array)):",
		  "            idx2 = idx+(idx & -idx)",
		  "            if idx2<len(self.array):",
		  "                self.array[idx2] += self.array[idx]",
		  "    ",
		  "    def prefix_query(self,idx):",
		  "        idx+=1",
		  "        result = 0",
		  "        while idx:",
		  "            result += self.array[idx]",
		  "            idx -= idx & -idx",
		  "        return result",
		  "    ",
		  "    def range_query(self,from_idx,to_idx):",
		  "        return self.prefix_query(to_idx) - self.prefix_query(from_idx-1)",
		  "    ",
		  "    def update(self,idx,add):",
		  "        idx+=1",
		  "        while idx<len(self.array):",
		  "            self.array[idx]+=add",
		  "            idx+= idx & -idx"
		],
		"description": "fenwick tree class"
	  },
	  "graphclass": {
		"prefix": "graphclass",
		"body": [
		  "import sys",
		  "from collections import deque as queue",
		  "sys.setrecursionlimit(10 ** 6)",
		  "class Graph(object):",
		  "",
		  "    def __init__(self):",
		  "        self.neighbours = {}",
		  "    ",
		  "    def __repr__(self):",
		  "        s = ''",
		  "        for i in self.neighbours:",
		  "            s += str(i)+': '+' '.join(map(str,self.neighbours[i])) + '\\n'",
		  "        return s",
		  "    ",
		  "    def add_node(self, node):",
		  "        self.neighbours[node] = set()",
		  "    ",
		  "    def add_edge(self, edge):",
		  "        u, v = edge",
		  "        self.neighbours[u].add(v)",
		  "        self.neighbours[v].add(u)",
		  "    ",
		  "    def dfs(self, node):",
		  "        visited[node] = 1",
		  "        for child in self.neighbours[node]:",
		  "            if visited[child] == 0:",
		  "                self.dfs(child)",
		  "    ",
		  "    def bfs(self, node):",
		  "        q = queue()",
		  "        visited[node] = 1",
		  "        q.append(node)",
		  "        while q:",
		  "            cur = q.popleft()",
		  "            for child in self.neighbours[cur]:",
		  "                if visited[child] == 0:",
		  "                    q.append(child)",
		  "                    visited[child] = 1",
		  "",
		  "g = Graph()",
		  "n, e = map(int, input().split())",
		  "for i in range(n):",
		  "    g.add_node(i+1)",
		  "for i in range(e):",
		  "    x, y = map(int, input().split())",
		  "    g.add_edge((x, y))",
		  "visited = [0] * (n + 1)"
		],
		"description": "graphclass"
	  },
	  "bootstrap": {
		"prefix": "bootstrap",
		"body": [
		  "from types import GeneratorType",
		  "def bootstrap(f, stack=[]):",
		  "    def wrappedfunc(*args, **kwargs):",
		  "        if stack:",
		  "            return f(*args, **kwargs)",
		  "        else:",
		  "            to = f(*args, **kwargs)",
		  "            while True:",
		  "                if type(to) is GeneratorType:",
		  "                    stack.append(to)",
		  "                    to = next(to)",
		  "                else:",
		  "                    stack.pop()",
		  "                    if not stack:",
		  "                        break",
		  "                    to = stack[-1].send(to)",
		  "            return to",
		  "    return wrappedfunc"
		],
		"description": "bootstrap"
	  },
	  "timer": {
		"prefix": "timer",
		"body": [
		  "import time",
		  "def timer(f):",
		  "    def wrapper(*args, **kwargs):",
		  "        start = time.time()",
		  "        rv = f(*args, **kwargs)",
		  "        total = time.time() - start",
		  "        print(\"Time taken: {}ms\".format(total*1000))",
		  "        return rv",
		  "    return wrapper"
		],
		"description": "timer"
	  },
	  "binPow": {
		"prefix": "binPow",
		"body": [
		  "def binPow(n, r):",
		  "    c = 1",
		  "    while r > 0:",
		  "        if r & 1:",
		  "            r -= 1",
		  "            c *= n",
		  "        r = r // 2",
		  "        n = n ** 2",
		  "    return c"
		],
		"description": "binPow"
	  },
	  "ceil": {
		"prefix": "ceil",
		"body": [
		  "def ceil(a, b):",
		  "    return (a + b - 1) // b"
		],
		"description": "ceil"
	  },
	  "skeleton": {
		"prefix": "skeleton",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "",
		  "",
		  "int i = 0,j = 0,k = 0;",
		  "#define INT             long long",
		  "#define mod             1000000007",
		  "#define inf             (int)1e18",
		  "#define endl            \"\\n\"",
		  "#define FOR(a, b)       for (int i = a; i < b;i++)",
		  "#define inpArr(vec)          for(auto &it:vec) cin>>it",
		  "#define outArr(vec)          for(auto &it:vec) cout<<it<<\" \";cout<<endl;",
		  "#define read(n) 			INT n;cin >> n;",
		  "#define readTwo(x, y) 		INT x, y;cin>>x>>y;",
		  "#define readThree(x, y, z) 	INT x, y, z;cin>>x>>y>>z;",
		  "#define readFour(x, y, z,a) INT x, y, z, a;cin>>x>>y>>z>>a;",
		  "",
		  "",
		  "void solve(){",
		  "	",
		  "}",
		  "",
		  "",
		  "",
		  "",
		  "int main(){",
		  "ios_base::sync_with_stdio(0);cin.tie(NULL);",
		  "",
		  "int tt=1;",
		  "cin >> tt;",
		  "while(tt--){",
		  "	solve();",
		  "}",
		  "",
		  "return 0;",
		  "	",
		  "}"
		],
		"description": "skeleton"
	  },
	  "debugCPP": {
		"prefix": "debugCpp",
		"body": [
		  "template<typename T>",
		  "int SIZE(T (&t)){",
		  "    return t.size();",
		  "}",
		  "",
		  "template<typename T, size_t N>",
		  "int SIZE(T (&t)[N]){",
		  "    return N;",
		  "}",
		  "",
		  "string to_string(char t){",
		  "    return \"'\" + string({t}) + \"'\";",
		  "}",
		  "",
		  "string to_string(bool t){",
		  "    return t ? \"true\" : \"false\";",
		  "}",
		  "",
		  "string to_string(const string &t, int x1=0, int x2=1e9){",
		  "    string ret = \"\";",
		  "    for(int i = min(x1,SIZE(t)), _i = min(x2,SIZE(t)-1); i <= _i; ++i){",
		  "        ret += t[i];",
		  "    }",
		  "    return '\"' + ret + '\"';",
		  "}",
		  "",
		  "string to_string(const char* t){",
		  "    string ret(t);",
		  "    return to_string(ret);",
		  "}",
		  "",
		  "template<size_t N>",
		  "string to_string(const bitset<N> &t, int x1=0, int x2=1e9){",
		  "    string ret = \"\";",
		  "    for(int i = min(x1,SIZE(t)); i <= min(x2,SIZE(t)-1); ++i){",
		  "        ret += t[i] + '0';",
		  "    }",
		  "    return to_string(ret);",
		  "}",
		  "",
		  "template<typename T, typename... Coords>",
		  "string to_string(const T (&t), int x1=0, int x2=1e9, Coords... C);",
		  "",
		  "template<typename T, typename S>",
		  "string to_string(const pair<T, S> &t){",
		  "    return \"(\" + to_string(t.first) + \", \" + to_string(t.second) + \")\";",
		  "}",
		  "",
		  "template<typename T, typename... Coords>",
		  "string to_string(const T (&t), int x1, int x2, Coords... C){",
		  "    string ret = \"[\";",
		  "    x1 = min(x1, SIZE(t));",
		  "    auto e = begin(t);",
		  "    advance(e,x1);",
		  "    for(int i = x1, _i = min(x2,SIZE(t)-1); i <= _i; ++i){",
		  "        ret += to_string(*e, C...) + (i != _i ? \", \" : \"\");",
		  "        e = next(e);",
		  "    }",
		  "    return ret + \"]\";",
		  "}",
		  "",
		  "template<int Index, typename... Ts>",
		  "struct print_tuple{",
		  "    string operator() (const tuple<Ts...>& t) {",
		  "        string ret = print_tuple<Index - 1, Ts...>{}(t);",
		  "        ret += (Index ? \", \" : \"\");",
		  "        return ret + to_string(get<Index>(t));",
		  "    }",
		  "};",
		  "",
		  "template<typename... Ts>",
		  "struct print_tuple<0, Ts...> {",
		  "    string operator() (const tuple<Ts...>& t) {",
		  "        return to_string(get<0>(t));",
		  "    }",
		  "};",
		  "",
		  "template<typename... Ts>",
		  "string to_string(const tuple<Ts...>& t) {",
		  "    const auto Size = tuple_size<tuple<Ts...>>::value;",
		  "    return print_tuple<Size - 1, Ts...>{}(t);",
		  "}",
		  "",
		  "void dbgr(){;}",
		  "template<typename Heads, typename... Tails>",
		  "void dbgr(Heads H, Tails... T){",
		  "    cout << to_string(H) << \" | \";",
		  "    dbgr(T...);",
		  "}",
		  "",
		  "void dbgs(){;}",
		  "template<typename Heads, typename... Tails>",
		  "void dbgs(Heads H, Tails... T){",
		  "    cout << H << \" \";",
		  "    dbgs(T...);",
		  "}",
		  "",
		  "/*",
		  "formatted functions:",
		  "*/",
		  "",
		  "/*",
		  "consider __VA_ARGS__ as a whole:",
		  "dbgv() prints values only",
		  "dbg() prints name and values",
		  "*/",
		  "#define dbgv(...) cout << to_string(__VA_ARGS__) << endl;",
		  "",
		  "#define dbg(...) cout << \"[\" << #__VA_ARGS__ << \"]: \"; dbgv(__VA_ARGS__);",
		  "",
		],
		"description": "debugCPP"
	  },
	  "mergeSort": {
		"prefix": "mergeSort",
		"body": [
		  "def mergesort(arr, n):",
		  "    temp_arr = [0] * n",
		  "    return _mergesort(arr, temp_arr, 0, n - 1)",
		  "",
		  "def _mergesort(arr, temp, l, r):",
		  "    ans = 0",
		  "    if l < r:",
		  "        mid = (l + r) // 2",
		  "        ans += _mergesort(arr, temp, l, mid)",
		  "        ans += _mergesort(arr, temp, mid + 1, r)",
		  "        ans += merge(arr, temp, l, mid, r)",
		  "    return ans",
		  "",
		  "def merge(arr, temp, l, mid, r):",
		  "    count = 0",
		  "    i = l",
		  "    j = mid + 1",
		  "    nxt = l",
		  "    while i <= mid and j <= r:",
		  "        if arr[i] <= arr[j]:",
		  "            temp[nxt] = arr[i]",
		  "            nxt += 1",
		  "            i += 1",
		  "        else:",
		  "            count += (mid - i + 1)",
		  "            temp[nxt] = arr[j]",
		  "            nxt += 1",
		  "            j += 1",
		  "    ",
		  "    while i <= mid:",
		  "        temp[nxt] = arr[i]",
		  "        nxt += 1",
		  "        i += 1",
		  "    ",
		  "    while j <= r:",
		  "        temp[nxt] = arr[j]",
		  "        nxt += 1",
		  "        j += 1",
		  "    ",
		  "    arr[l:r+1] = temp[l:r+1][:]",
		  "    ",
		  "    return count",
		  ""
		],
		"description": "mergeSort"
	  }
}